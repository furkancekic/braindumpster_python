{% extends "base.html" %}

{% block content %}
<div class="container mx-auto p-4 chat-container">
    <div class="bg-white rounded-lg shadow-lg h-full flex flex-col">
        <!-- Header -->
        <div class="bg-blue-600 text-white p-4 rounded-t-lg">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-xl font-bold">AI Task Scheduler</h1>
                    <p class="text-blue-100">Tell me what you want to accomplish, and I'll help you organize it!</p>
                </div>
                <div class="flex space-x-2">
                    <button onclick="showMyReminders()" class="bg-blue-700 hover:bg-blue-800 px-4 py-2 rounded text-sm">
                        üîî My Reminders
                    </button>
                    <a href="/dashboard" class="bg-blue-700 hover:bg-blue-800 px-4 py-2 rounded text-sm">
                        üìä Dashboard
                    </a>
                    <button onclick="signOutUser()" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded text-sm">
                        Sign Out
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Chat Messages -->
        <div id="chatMessages" class="flex-1 p-4 overflow-y-auto space-y-4">
            <div class="message-bubble bg-gray-200 p-3 rounded-lg">
                <p class="text-gray-800">üëã Hello! I'm your AI task scheduler. Tell me what you're planning to do, and I'll help you organize it into actionable tasks with reminders.</p>
            </div>
        </div>
        
        <!-- Input Area -->
        <div class="p-4 border-t">
            <div class="flex space-x-2">
                <input 
                    type="text" 
                    id="messageInput" 
                    placeholder="Tell me what you want to accomplish..."
                    class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    onkeypress="handleKeyPress(event)"
                >
                <button 
                    id="micButton"
                    onclick="toggleVoiceRecording()"
                    class="bg-gray-600 text-white px-4 py-3 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors"
                    title="Voice input"
                >
                    üé§
                </button>
                <button 
                    onclick="sendUserMessage()"
                    class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                    Send
                </button>
            </div>
            <div id="voiceStatus" class="mt-2 text-sm text-center text-gray-600 hidden">
                Listening... Speak now
            </div>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script>
    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyCIjfY8IDQg4NRgsWF5yEHFTyFYRnJALi4",
        authDomain: "voicereminder-e1c91.firebaseapp.com",
        databaseURL: "https://voicereminder-e1c91-default-rtdb.firebaseio.com",
        projectId: "voicereminder-e1c91",
        storageBucket: "voicereminder-e1c91.firebasestorage.app",
        messagingSenderId: "28669271299",
        appId: "1:28669271299:web:7a951160eae3df5a141d36"
    };
    
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    
    let currentUserId = null;
    let currentUserToken = null;
    let currentConversationId = null;
    
    // Check authentication state
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            currentUserId = user.uid;
            currentUserToken = await user.getIdToken();
            console.log('User authenticated:', currentUserId);
            // Show authenticated UI
            document.getElementById('chatMessages').style.display = 'block';
            document.querySelector('.p-4.border-t').style.display = 'block';
        } else {
            console.log('User not authenticated');
            showAuthenticationPrompt();
        }
    });
    
    function showAuthenticationPrompt() {
        document.getElementById('chatMessages').innerHTML = `
            <div class="text-center py-8">
                <span class="text-4xl">üîê</span>
                <h2 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Authentication Required</h2>
                <p class="text-gray-600 mb-6">Please sign in to start chatting</p>
                <div class="space-y-4">
                    <div>
                        <input type="email" id="emailInput" placeholder="Email" class="w-full max-w-sm mx-auto block border border-gray-300 rounded px-4 py-2 mb-2" />
                        <input type="password" id="passwordInput" placeholder="Password" class="w-full max-w-sm mx-auto block border border-gray-300 rounded px-4 py-2 mb-4" />
                    </div>
                    <div class="space-x-2">
                        <button onclick="signInUser()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700">
                            Sign In
                        </button>
                        <button onclick="signUpUser()" class="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700">
                            Sign Up
                        </button>
                    </div>
                </div>
            </div>
        `;
        // Hide input area
        document.querySelector('.p-4.border-t').style.display = 'none';
    }
    
    async function signInUser() {
        const email = document.getElementById('emailInput').value;
        const password = document.getElementById('passwordInput').value;
        
        if (!email || !password) {
            alert('Please enter both email and password');
            return;
        }
        
        try {
            await auth.signInWithEmailAndPassword(email, password);
            // Reset chat messages to welcome
            document.getElementById('chatMessages').innerHTML = `
                <div class="message-bubble bg-gray-200 p-3 rounded-lg">
                    <p class="text-gray-800">üëã Hello! I'm your AI task scheduler. Tell me what you're planning to do, and I'll help you organize it into actionable tasks with reminders.</p>
                </div>
            `;
        } catch (error) {
            console.error('Sign in error:', error);
            alert('Sign in failed: ' + error.message);
        }
    }
    
    async function signUpUser() {
        const email = document.getElementById('emailInput').value;
        const password = document.getElementById('passwordInput').value;
        
        if (!email || !password) {
            alert('Please enter both email and password');
            return;
        }
        
        try {
            const userCredential = await auth.createUserWithEmailAndPassword(email, password);
            const user = userCredential.user;
            
            // Register user with backend
            const idToken = await user.getIdToken();
            const response = await fetch('/api/auth/register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify({
                    email: user.email,
                    display_name: user.displayName || user.email.split('@')[0]
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to register user with backend');
            }
            
            alert('Account created successfully!');
            // Reset chat messages to welcome
            document.getElementById('chatMessages').innerHTML = `
                <div class="message-bubble bg-gray-200 p-3 rounded-lg">
                    <p class="text-gray-800">üëã Hello! I'm your AI task scheduler. Tell me what you're planning to do, and I'll help you organize it into actionable tasks with reminders.</p>
                </div>
            `;
        } catch (error) {
            console.error('Sign up error:', error);
            alert('Sign up failed: ' + error.message);
        }
    }
    
    function signOutUser() {
        auth.signOut();
    }
    
    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendUserMessage();
        }
    }
    
    async function sendUserMessage() {
        if (!currentUserId || !currentUserToken) return;
        
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (!message) return;
        
        // Add user message to chat
        addMessageToChat(message, 'user');
        input.value = '';
        
        // Add loading indicator
        const loadingId = addLoadingMessage();
        
        try {
            const response = await sendMessage(message, currentUserId, currentUserToken);
            
            // Remove loading indicator
            removeLoadingMessage(loadingId);
            
            if (response.error) {
                addMessageToChat('Sorry, I encountered an error: ' + response.error, 'assistant');
                return;
            }
            
            currentConversationId = response.conversation_id;
            
            // Display AI response
            displayAIResponse(response.response);
            
        } catch (error) {
            removeLoadingMessage(loadingId);
            addMessageToChat('Sorry, I encountered an error. Please try again.', 'assistant');
        }
    }
    
    function addMessageToChat(message, role) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        
        if (role === 'user') {
            messageDiv.className = 'message-bubble bg-blue-600 text-white p-3 rounded-lg ml-auto';
        } else {
            messageDiv.className = 'message-bubble bg-gray-200 p-3 rounded-lg';
        }
        
        messageDiv.innerHTML = `<p>${message}</p>`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        return messageDiv;
    }
    
    function addLoadingMessage() {
        const chatMessages = document.getElementById('chatMessages');
        const loadingDiv = document.createElement('div');
        const loadingId = 'loading-' + Date.now();
        
        loadingDiv.id = loadingId;
        loadingDiv.className = 'message-bubble bg-gray-200 p-3 rounded-lg';
        loadingDiv.innerHTML = '<p>ü§î Thinking...</p>';
        
        chatMessages.appendChild(loadingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        return loadingId;
    }
    
    function removeLoadingMessage(loadingId) {
        const loadingDiv = document.getElementById(loadingId);
        if (loadingDiv) {
            loadingDiv.remove();
        }
    }
    
    function displayAIResponse(response) {
        const chatMessages = document.getElementById('chatMessages');
        const responseDiv = document.createElement('div');
        responseDiv.className = 'message-bubble bg-gray-200 p-3 rounded-lg';
        
        // Check query type and handle accordingly
        if (response.analysis && response.analysis.query_type === 'duplicate_found') {
            // Handle duplicate task found
            displayDuplicateTaskFound(response, responseDiv, chatMessages);
            return;
        } else if (response.analysis && response.analysis.query_type === 'information_query') {
            let html = '<div class="space-y-3">';
            
            // Check if the response contains reminder information
            if (response.analysis.existing_reminders_summary) {
                const summaryText = response.analysis.existing_reminders_summary;
                
                // Check for any reminder content
                if (summaryText.includes('reminders') || summaryText.includes('Reminder') || 
                    summaryText.includes('G√∂rev') || summaryText.includes('for task:') || 
                    summaryText.includes('Due:')) {
                    
                    // Try to parse as task list first
                    if (summaryText.includes('Due:')) {
                        html += '<p class="font-semibold text-gray-800 mb-3">üìã Your Upcoming Tasks:</p>';
                        
                        // Parse task blocks
                        const taskBlocks = summaryText.split(/(?=\w+.*\n.*Due:)/);
                        
                        taskBlocks.forEach(block => {
                            if (block.trim()) {
                                const lines = block.trim().split('\n');
                                let taskTitle = '';
                                let description = '';
                                let dueDate = '';
                                
                                lines.forEach(line => {
                                    if (line.includes('Due:')) {
                                        dueDate = line.replace('Due:', '').trim();
                                    } else if (!description && !line.includes('Due:') && line.trim()) {
                                        if (!taskTitle) {
                                            taskTitle = line.trim();
                                        } else {
                                            description = line.trim();
                                        }
                                    }
                                });
                                
                                if (taskTitle) {
                                    html += `
                                        <div class="border border-gray-300 p-3 rounded-lg bg-white mb-3">
                                            <h4 class="font-semibold text-gray-800">${taskTitle}</h4>
                                            ${description ? `<p class="text-gray-600 text-sm mt-1">${description}</p>` : ''}
                                            <div class="flex items-center mt-2 space-x-4 text-xs text-gray-500">
                                                ${dueDate ? `<span>üìÖ ${formatDate(dueDate)}</span>` : ''}
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                        });
                    } else {
                        // Parse as reminder lines
                        html += '<p class="font-semibold text-gray-800 mb-3">üîî Your Upcoming Reminders:</p>';
                        
                        const reminderLines = summaryText.split('\n').filter(line => 
                            line.trim().startsWith('-') || line.trim().startsWith('*')
                        );
                        
                        reminderLines.forEach(line => {
                            // Handle different formats
                            let match = line.match(/[*-] (.+?): (.+?) \(for task: (.+?)\)/);
                            if (!match) {
                                // Try alternative format: * TaskName (Reminder: time)
                                match = line.match(/[*-] (.+?) \(Hatƒ±rlatƒ±cƒ±: (.+?)\)/);
                                if (match) {
                                    const [, taskTitle, time] = match;
                                    html += `
                                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-2">
                                            <div class="flex items-start space-x-3">
                                                <div class="text-blue-600">üìã</div>
                                                <div class="flex-1">
                                                    <p class="text-sm font-medium text-blue-800">${taskTitle}</p>
                                                    <p class="text-xs text-blue-600 mt-1">üìÖ ${formatDate(time)}</p>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }
                            } else {
                                // Original format: - time: message (for task: name)
                                const [, time, message, taskTitle] = match;
                                html += `
                                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-2">
                                        <div class="flex items-start space-x-3">
                                            <div class="text-yellow-600">üîî</div>
                                            <div class="flex-1">
                                                <p class="text-sm font-medium text-yellow-800">${message}</p>
                                                <p class="text-xs text-yellow-600 mt-1">üìÖ ${formatDate(time)}</p>
                                                <p class="text-xs text-gray-600 mt-1">Task: ${taskTitle}</p>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                        });
                    }
                } else {
                    // Show other types of information summaries as before
                    html += `<div class="bg-blue-50 border border-blue-200 rounded p-3">
                        <p class="text-blue-800">${summaryText}</p>
                    </div>`;
                }
            }
            
            // Show suggestions/information
            if (response.suggestions && response.suggestions.length > 0) {
                response.suggestions.forEach(suggestion => {
                    if (suggestion.type === 'information') {
                        html += `<div class="bg-gray-50 border border-gray-200 rounded p-3">
                            <h4 class="font-semibold text-gray-700 mb-1">${suggestion.title}</h4>
                            <p class="text-gray-600 text-sm">${suggestion.description}</p>
                        </div>`;
                    }
                });
            }
            
            // If no information available
            if (!response.analysis.existing_reminders_summary && (!response.suggestions || response.suggestions.length === 0)) {
                html += '<p class="text-gray-600">No saved tasks or reminders found.</p>';
            }
            
            html += '</div>';
            responseDiv.innerHTML = html;
        } else if (response.success && response.tasks && response.tasks.length > 0) {
            // Store tasks for refinement
            lastGeneratedTasks = response.tasks;
            let html = '<div class="space-y-3">';
            html += '<p class="font-semibold text-gray-800">I\'ve created a plan for you:</p>';
            
            // Sort tasks by due_date before displaying
            const sortedTasks = response.tasks.sort((a, b) => {
                if (a.due_date && b.due_date) {
                    return new Date(a.due_date) - new Date(b.due_date);
                }
                if (a.due_date && !b.due_date) return -1;
                if (!a.due_date && b.due_date) return 1;
                return 0;
            });
            
            // Display tasks
            sortedTasks.forEach((task, index) => {
                html += `
                    <div class="border border-gray-300 p-3 rounded-lg bg-white">
                        <h4 class="font-semibold text-gray-800">${task.title}</h4>
                        <p class="text-gray-600 text-sm mt-1">${task.description}</p>
                        <div class="flex items-center mt-2 space-x-4 text-xs text-gray-500">
                            <span class="bg-${getPriorityColor(task.priority)}-100 text-${getPriorityColor(task.priority)}-800 px-2 py-1 rounded">
                                ${task.priority} priority
                            </span>
                            ${task.due_date ? `<span>üìÖ ${formatDate(task.due_date)}</span>` : ''}
                            ${task.estimated_duration ? `<span>‚è±Ô∏è ${task.estimated_duration} min</span>` : ''}
                            ${task.reminders && task.reminders.length > 0 ? `<span>üîî ${task.reminders.length} reminders</span>` : ''}
                        </div>
                        ${task.reminders && task.reminders.length > 0 ? `
                            <div class="mt-2 bg-yellow-50 border border-yellow-200 rounded p-2">
                                <p class="text-xs font-medium text-yellow-800 mb-1">üîî Reminders:</p>
                                ${task.reminders.map(reminder => `
                                    <div class="text-xs text-yellow-700">
                                        ‚Ä¢ ${formatDate(reminder.reminder_time)}: ${reminder.message}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Add approval buttons
            html += `
                <div class="flex space-x-2 mt-4">
                    <button 
                        onclick="approveAllTasks(${JSON.stringify(response.tasks).replace(/"/g, '&quot;')})"
                        class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
                    >
                        ‚úÖ Approve All
                    </button>
                    <button 
                        onclick="provideFeedback()"
                        class="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700 text-sm"
                    >
                        üîÑ Suggest Changes
                    </button>
                </div>
            `;
            
            html += '</div>';
            responseDiv.innerHTML = html;
        } else {
            // Handle responses without tasks but potentially with suggestions
            let html = '<div class="space-y-3">';
            
            // Show suggestions if available
            if (response.suggestions && response.suggestions.length > 0) {
                html += '<p class="font-semibold text-gray-800 mb-3">üí° Suggestions:</p>';
                
                response.suggestions.forEach(suggestion => {
                    const iconMap = {
                        'optimization': '‚ö°',
                        'alternative': 'üîÑ',
                        'additional': '‚ûï',
                        'information': '‚ÑπÔ∏è'
                    };
                    const icon = iconMap[suggestion.type] || 'üí°';
                    
                    html += `
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                            <h4 class="font-semibold text-gray-700 mb-1">${icon} ${suggestion.title}</h4>
                            <p class="text-gray-600 text-sm mb-2">${suggestion.description}</p>
                            ${suggestion.reasoning ? `<p class="text-gray-500 text-xs italic">${suggestion.reasoning}</p>` : ''}
                        </div>
                    `;
                });
            }
            
            // Show next steps if available
            if (response.next_steps && response.next_steps.length > 0) {
                html += '<p class="font-semibold text-gray-800 mb-3 mt-4">üìã Next Steps:</p>';
                html += '<div class="bg-blue-50 border border-blue-200 rounded-lg p-3">';
                html += '<ol class="list-decimal list-inside space-y-1">';
                response.next_steps.forEach(step => {
                    html += `<li class="text-blue-800 text-sm">${step}</li>`;
                });
                html += '</ol></div>';
            }
            
            // If no suggestions or next steps, show default message
            if ((!response.suggestions || response.suggestions.length === 0) && 
                (!response.next_steps || response.next_steps.length === 0)) {
                html += `<p class="text-gray-600">${response.raw_response || 'I understand what you want to do, but I need more details to create specific tasks.'}</p>`;
            }
            
            html += '</div>';
            responseDiv.innerHTML = html;
        }
        
        chatMessages.appendChild(responseDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function getPriorityColor(priority) {
        const colors = {
            'urgent': 'red',
            'high': 'orange',
            'medium': 'blue',
            'low': 'gray'
        };
        return colors[priority] || 'gray';
    }
    
    function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }
    
    async function approveAllTasks(tasks) {
        try {
            // Create tasks in database
            const createResponse = await fetch('/api/tasks/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${currentUserToken}`
                },
                body: JSON.stringify({
                    user_id: currentUserId,
                    tasks: tasks,
                    conversation_id: currentConversationId
                })
            });
            
            const result = await createResponse.json();
            
            if (result.error) {
                addMessageToChat('Error creating tasks: ' + result.error, 'assistant');
                return;
            }
            
            // Approve the created tasks
            const taskIds = result.created_tasks.map(t => t.id);
            const approveResponse = await approveTasks(taskIds, currentUserId, currentUserToken);
            
            if (approveResponse.error) {
                addMessageToChat('Tasks created but approval failed: ' + approveResponse.error, 'assistant');
                return;
            }
            
            addMessageToChat(`‚úÖ Perfect! I've created and approved ${result.count} tasks for you. You can view them in your dashboard.`, 'assistant');
            
        } catch (error) {
            addMessageToChat('Sorry, there was an error creating your tasks. Please try again.', 'assistant');
        }
    }
    
    let lastGeneratedTasks = null;
    
    async function provideFeedback() {
        const feedback = prompt("What would you like me to change about these tasks?");
        if (feedback && lastGeneratedTasks) {
            addMessageToChat(feedback, 'user');
            
            const loadingId = addLoadingMessage();
            
            try {
                const response = await fetch('/api/chat/refine', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentUserToken}`
                    },
                    body: JSON.stringify({
                        user_id: currentUserId,
                        original_tasks: lastGeneratedTasks,
                        feedback: feedback,
                        conversation_id: currentConversationId
                    })
                });
                
                const result = await response.json();
                removeLoadingMessage(loadingId);
                
                if (result.error) {
                    addMessageToChat('Sorry, I encountered an error refining your tasks: ' + result.error, 'assistant');
                } else if (result.refined_tasks) {
                    // Display refined tasks with changes summary
                    displayRefinedTasks(result.refined_tasks);
                } else {
                    addMessageToChat('Tasks have been refined based on your feedback.', 'assistant');
                }
                
            } catch (error) {
                removeLoadingMessage(loadingId);
                addMessageToChat('Sorry, I encountered an error refining your tasks. Please try again.', 'assistant');
            }
        } else if (!lastGeneratedTasks) {
            alert("No tasks to refine. Please generate some tasks first.");
        }
    }
    
    function displayRefinedTasks(refinedResponse) {
        const chatMessages = document.getElementById('chatMessages');
        const responseDiv = document.createElement('div');
        responseDiv.className = 'message-bubble bg-gray-200 p-3 rounded-lg';
        
        let html = '<div class="space-y-3">';
        
        // Show changes summary if available
        if (refinedResponse.changes_made) {
            html += '<div class="bg-blue-50 border border-blue-200 rounded p-3 mb-4">';
            html += '<h4 class="font-semibold text-blue-800 mb-2">üîÑ Changes Made:</h4>';
            html += `<p class="text-blue-700 text-sm">${refinedResponse.changes_made.summary}</p>`;
            html += '</div>';
        }
        
        html += '<p class="font-semibold text-gray-800">I\'ve refined your tasks based on your feedback:</p>';
        
        if (refinedResponse.success && refinedResponse.tasks && refinedResponse.tasks.length > 0) {
            // Store refined tasks for further refinement
            lastGeneratedTasks = refinedResponse.tasks;
            
            // Display refined tasks
            refinedResponse.tasks.forEach((task, index) => {
                html += `
                    <div class="border border-gray-300 p-3 rounded-lg bg-white">
                        <h4 class="font-semibold text-gray-800">${task.title}</h4>
                        <p class="text-gray-600 text-sm mt-1">${task.description}</p>
                        <div class="flex items-center mt-2 space-x-4 text-xs text-gray-500">
                            <span class="bg-${getPriorityColor(task.priority)}-100 text-${getPriorityColor(task.priority)}-800 px-2 py-1 rounded">
                                ${task.priority} priority
                            </span>
                            ${task.due_date ? `<span>üìÖ ${formatDate(task.due_date)}</span>` : ''}
                            ${task.estimated_duration ? `<span>‚è±Ô∏è ${task.estimated_duration} min</span>` : ''}
                            ${task.reminders && task.reminders.length > 0 ? `<span>üîî ${task.reminders.length} reminders</span>` : ''}
                        </div>
                        ${task.reminders && task.reminders.length > 0 ? `
                            <div class="mt-2 bg-yellow-50 border border-yellow-200 rounded p-2">
                                <p class="text-xs font-medium text-yellow-800 mb-1">üîî Reminders:</p>
                                ${task.reminders.map(reminder => `
                                    <div class="text-xs text-yellow-700">
                                        ‚Ä¢ ${formatDate(reminder.reminder_time)}: ${reminder.message}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Add approval buttons for refined tasks
            html += `
                <div class="flex space-x-2 mt-4">
                    <button 
                        onclick="approveAllTasks(${JSON.stringify(refinedResponse.tasks).replace(/"/g, '&quot;')})"
                        class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
                    >
                        ‚úÖ Approve Refined Tasks
                    </button>
                    <button 
                        onclick="provideFeedback()"
                        class="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700 text-sm"
                    >
                        üîÑ Suggest More Changes
                    </button>
                </div>
            `;
        }
        
        // Show alternatives if available
        if (refinedResponse.alternatives && refinedResponse.alternatives.length > 0) {
            html += '<div class="bg-gray-50 border border-gray-200 rounded p-3 mt-4">';
            html += '<h4 class="font-semibold text-gray-700 mb-2">üí° Alternative Approaches:</h4>';
            refinedResponse.alternatives.forEach(alt => {
                html += `
                    <div class="mb-2">
                        <p class="font-medium text-gray-800">${alt.title}</p>
                        <p class="text-gray-600 text-sm">${alt.description}</p>
                    </div>
                `;
            });
            html += '</div>';
        }
        
        html += '</div>';
        responseDiv.innerHTML = html;
        
        chatMessages.appendChild(responseDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    async function showMyReminders() {
        const chatMessages = document.getElementById('chatMessages');
        
        try {
            const response = await fetch(`/api/tasks/reminders/${currentUserId}`, {
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`
                }
            });
            const result = await response.json();
            
            if (result.error) {
                addMessageToChat('Sorry, I couldn\'t fetch your reminders: ' + result.error, 'assistant');
                return;
            }
            
            const responseDiv = document.createElement('div');
            responseDiv.className = 'message-bubble bg-gray-200 p-3 rounded-lg';
            
            let html = '<div class="space-y-3">';
            html += '<p class="font-semibold text-gray-800">üîî Your Upcoming Reminders:</p>';
            
            if (result.reminders && result.reminders.length > 0) {
                html += '<div class="space-y-2">';
                result.reminders.forEach(reminder => {
                    html += `
                        <div class="bg-yellow-50 border border-yellow-200 rounded p-3">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="text-sm font-medium text-yellow-800">${reminder.message}</p>
                                    <p class="text-xs text-yellow-600 mt-1">üìÖ ${formatDate(reminder.reminder_time)}</p>
                                    <p class="text-xs text-gray-600 mt-1">Task: ${reminder.task_title}</p>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            } else {
                html += '<p class="text-gray-600">You don\'t have any upcoming reminders.</p>';
            }
            
            html += '</div>';
            responseDiv.innerHTML = html;
            
            chatMessages.appendChild(responseDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
        } catch (error) {
            addMessageToChat('Sorry, there was an error fetching your reminders.', 'assistant');
        }
    }
    
    // Function to check if task has active reminders (used in dashboard)
    function hasActiveReminders(task) {
        if (!task.reminders || task.reminders.length === 0) return false;
        return task.reminders.some(reminder => !reminder.sent);
    }
    
    // Function to display duplicate task found
    function displayDuplicateTaskFound(response, responseDiv, chatMessages) {
        let html = '<div class="space-y-3">';
        
        html += '<p class="font-semibold text-orange-800 mb-3">‚ö†Ô∏è Similar Task Found:</p>';
        html += '<p class="text-gray-700 mb-3">You already have a similar task. Here\'s the existing task:</p>';
        
        // Parse existing task from analysis
        let existingTask;
        try {
            if (typeof response.analysis.existing_task === 'string') {
                // Try to extract task info from string format
                const taskText = response.analysis.existing_task;
                existingTask = parseTaskFromText(taskText);
            } else {
                existingTask = response.analysis.existing_task;
            }
        } catch (e) {
            console.error('Error parsing existing task:', e);
        }
        
        if (existingTask) {
            // Display existing task as a block (similar to task approval)
            html += `
                <div class="border border-orange-300 p-3 rounded-lg bg-orange-50">
                    <h4 class="font-semibold text-orange-800">${existingTask.title || 'Existing Task'}</h4>
                    <p class="text-orange-700 text-sm mt-1">${existingTask.description || 'No description'}</p>
                    <div class="flex items-center mt-2 space-x-4 text-xs text-orange-600">
                        ${existingTask.priority ? `<span class="bg-orange-200 text-orange-800 px-2 py-1 rounded">${existingTask.priority} priority</span>` : ''}
                        ${existingTask.due_date ? `<span>üìÖ ${formatDate(existingTask.due_date)}</span>` : ''}
                        ${existingTask.reminders && existingTask.reminders.length > 0 ? `<span>üîî ${existingTask.reminders.length} reminders</span>` : ''}
                    </div>
                    ${existingTask.reminders && existingTask.reminders.length > 0 ? `
                        <div class="mt-2 bg-yellow-50 border border-yellow-200 rounded p-2">
                            <p class="text-xs font-medium text-yellow-800 mb-1">üîî Reminders:</p>
                            ${existingTask.reminders.map(reminder => `
                                <div class="text-xs text-yellow-700">
                                    ‚Ä¢ ${formatDate(reminder.reminder_time)}: ${reminder.message}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Add action buttons
            html += `
                <div class="flex space-x-2 mt-4">
                    <button 
                        onclick="updateExistingTask('${existingTask.id || ''}')"
                        class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm"
                    >
                        üîÑ Update This Task
                    </button>
                    <button 
                        onclick="keepExistingTask()"
                        class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
                    >
                        ‚úÖ Keep As Is
                    </button>
                    <button 
                        onclick="createNewTaskAnyway()"
                        class="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 text-sm"
                    >
                        ‚ûï Create New Anyway
                    </button>
                </div>
            `;
        }
        
        // Show suggestions if available
        if (response.suggestions && response.suggestions.length > 0) {
            html += '<div class="mt-4">';
            html += '<p class="font-semibold text-gray-800 mb-2">üí° Suggestions:</p>';
            response.suggestions.forEach(suggestion => {
                html += `
                    <div class="bg-gray-50 border border-gray-200 rounded p-2 mb-2">
                        <p class="text-gray-700 text-sm">${suggestion.description}</p>
                    </div>
                `;
            });
            html += '</div>';
        }
        
        html += '</div>';
        responseDiv.innerHTML = html;
        chatMessages.appendChild(responseDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Helper function to parse task from text format
    function parseTaskFromText(taskText) {
        const lines = taskText.split('\n');
        let task = {};
        
        lines.forEach(line => {
            if (line.includes('Task:')) {
                task.title = line.replace('Task:', '').trim();
            } else if (line.includes('Description:')) {
                task.description = line.replace('Description:', '').trim();
            } else if (line.includes('Due:')) {
                task.due_date = line.replace('Due:', '').trim();
            } else if (line.includes('Reminder:')) {
                if (!task.reminders) task.reminders = [];
                const reminderText = line.replace('Reminder:', '').trim();
                task.reminders.push({ message: reminderText, reminder_time: task.due_date });
            }
        });
        
        return task;
    }
    
    // Action functions for duplicate task handling
    function updateExistingTask(taskId) {
        addMessageToChat('I\'ll help you update the existing task. What would you like to change?', 'assistant');
        // Store task ID for potential update
        window.pendingTaskUpdate = taskId;
    }
    
    function keepExistingTask() {
        addMessageToChat('Great! Your existing task is kept as is. No changes needed.', 'assistant');
    }
    
    function createNewTaskAnyway() {
        addMessageToChat('Understood. Please provide more details for the new task, and I\'ll create it as a separate task.', 'assistant');
    }
    
    // Audio recording functionality
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    
    // Initialize audio recording
    function initAudioRecording() {
        console.log('Checking audio recording support...');
        console.log('Location protocol:', location.protocol);
        console.log('Location hostname:', location.hostname);
        console.log('navigator.mediaDevices:', !!navigator.mediaDevices);
        console.log('getUserMedia:', !!navigator.mediaDevices?.getUserMedia);
        console.log('MediaRecorder:', !!window.MediaRecorder);
        
        // Check if running on HTTPS or localhost
        const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        
        if (!isSecureContext) {
            console.warn('Audio recording requires HTTPS. Current protocol:', location.protocol);
            return false;
        }
        
        // Check for modern getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.warn('Modern audio recording not supported');
            
            // Try legacy getUserMedia
            const legacyGetUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            if (!legacyGetUserMedia) {
                console.warn('No getUserMedia support found');
                return false;
            } else {
                console.log('Legacy getUserMedia found, setting up polyfill');
                // Create a polyfill for modern browsers
                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = {};
                }
                if (!navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia = function(constraints) {
                        return new Promise((resolve, reject) => {
                            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    };
                }
            }
        }
        
        if (!window.MediaRecorder) {
            console.warn('MediaRecorder API not supported in this browser');
            return false;
        }
        
        console.log('Audio recording support: OK');
        return true;
    }
    
    // Toggle audio recording
    function toggleVoiceRecording() {
        if (!initAudioRecording()) {
            let errorMessage = 'Audio recording is not supported. ';
            
            // Check if running on HTTPS or localhost
            const isSecureContext = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            
            if (!isSecureContext) {
                errorMessage += 'Voice recording requires HTTPS. Please access this site via HTTPS.';
            } else if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                errorMessage += 'Your browser does not support audio recording.';
            } else if (!window.MediaRecorder) {
                errorMessage += 'MediaRecorder API is not supported in your browser.';
            } else {
                errorMessage += 'Please use a modern browser with microphone support.';
            }
            
            alert(errorMessage);
            return;
        }
        
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }
    
    // Start audio recording
    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100,
                } 
            });
            
            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });
            
            mediaRecorder.ondataavailable = function(event) {
                audioChunks.push(event.data);
            };
            
            mediaRecorder.onstop = function() {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                transcribeAudio(audioBlob);
                
                // Stop all tracks to release microphone
                stream.getTracks().forEach(track => track.stop());
            };
            
            mediaRecorder.start();
            isRecording = true;
            updateMicrophoneUI(true);
            showVoiceStatus('Recording... Speak now');
            
        } catch (error) {
            console.error('Error starting recording:', error);
            let errorMessage = 'Could not start recording.';
            
            if (error.name === 'NotAllowedError') {
                errorMessage = 'Microphone permission denied. Please allow microphone access.';
            } else if (error.name === 'NotFoundError') {
                errorMessage = 'No microphone found. Please connect a microphone.';
            }
            
            showVoiceStatus(errorMessage, true);
            setTimeout(hideVoiceStatus, 3000);
        }
    }
    
    // Stop audio recording
    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            updateMicrophoneUI(false);
            showVoiceStatus('Processing audio...');
        }
    }
    
    // Process audio directly with Gemini
    async function transcribeAudio(audioBlob) {
        if (!currentUserId || !currentUserToken) {
            hideVoiceStatus();
            addMessageToChat('Please sign in to use voice chat.', 'assistant');
            return;
        }
        
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');
            if (currentConversationId) {
                formData.append('conversation_id', currentConversationId);
            }
            
            showVoiceStatus('Processing audio with AI...');
            
            const response = await fetch('/api/chat/send-audio', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${currentUserToken}`
                },
                body: formData
            });
            
            const result = await response.json();
            
            if (result.error) {
                hideVoiceStatus();
                addMessageToChat('Sorry, there was an error processing your audio: ' + result.error, 'assistant');
            } else {
                // Update conversation ID
                currentConversationId = result.conversation_id;
                
                // Add user audio message to chat
                addMessageToChat('[Audio Message]', 'user');
                
                // Add AI response to chat
                if (result.response) {
                    displayAIResponse(result.response);
                }
                
                hideVoiceStatus();
            }
            
        } catch (error) {
            hideVoiceStatus();
            addMessageToChat('Sorry, there was an error processing your audio message.', 'assistant');
            console.error('Audio processing error:', error);
        }
    }
    
    // Keep the original upload function for reference (not used anymore)
    async function uploadAudio(audioBlob) {
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');
            formData.append('user_id', currentUserId);
            if (currentConversationId) {
                formData.append('conversation_id', currentConversationId);
            }
            
            const loadingId = addLoadingMessage();
            
            const response = await fetch('/api/chat/send-audio', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            removeLoadingMessage(loadingId);
            hideVoiceStatus();
            
            if (result.error) {
                addMessageToChat('Sorry, there was an error processing your audio: ' + result.error, 'assistant');
            } else {
                // Add audio message indicator to chat
                addMessageToChat('[üé§ Audio Message]', 'user');
                
                // Update conversation ID
                currentConversationId = result.conversation_id;
                
                // Display AI response
                displayAIResponse(result.response);
            }
            
        } catch (error) {
            hideVoiceStatus();
            addMessageToChat('Sorry, there was an error uploading your audio message.', 'assistant');
            console.error('Audio upload error:', error);
        }
    }
    
    // Update microphone button UI
    function updateMicrophoneUI(isActive) {
        const micButton = document.getElementById('micButton');
        if (isActive) {
            micButton.className = 'bg-red-600 text-white px-4 py-3 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 transition-colors animate-pulse';
            micButton.innerHTML = 'üî¥';
            micButton.title = 'Stop recording';
        } else {
            micButton.className = 'bg-gray-600 text-white px-4 py-3 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors';
            micButton.innerHTML = 'üé§';
            micButton.title = 'Voice input';
        }
    }
    
    // Show voice status message
    function showVoiceStatus(message, isError = false) {
        const statusDiv = document.getElementById('voiceStatus');
        statusDiv.textContent = message;
        statusDiv.className = `mt-2 text-sm text-center ${isError ? 'text-red-600' : 'text-blue-600'}`;
        statusDiv.classList.remove('hidden');
    }
    
    // Hide voice status
    function hideVoiceStatus() {
        const statusDiv = document.getElementById('voiceStatus');
        statusDiv.classList.add('hidden');
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize audio recording if supported
        initAudioRecording();
    });
</script>
{% endblock %}